/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "selec.h"

bool_t
fil_1_svc(void *argp, char **result, struct svc_req *rqstp)
{
	bool_t retval = 1;

	FILE *fp; // File pointer variable is created
        char c;
        int i =0,j=0;
        char* temp = malloc(sizeof(char) * 10000);
        fp = popen("who", "r"); // using who command and storing result in fp
        char text[100000];
        while( (c = getc(fp)) != EOF)
        {
        text[i] = c; //storing each character into text variable
        i++;
        }
	text[i+1] = '\0';
        strcpy(temp,text); //copying text variable to temp variable
        pclose(fp);
        *result=temp;
      	return retval;
}

bool_t
rev_1_svc(listt *argp, char **result, struct svc_req *rqstp)
{
	bool_t retval = 1;
        char* temp = malloc(sizeof(char) * 10000);
	char* tempp = malloc(sizeof(char) * 10000);
        int a,b,c,j=0;
        *result = argp->st; //using pointers to access the method arguments
	a = strlen(*result); //finding the length of the string
	tempp = *result;
	for(c = a - 1, b = 0; c >= 0; c--, b++)
        {
        temp[b] = tempp[c]; //reversing the string and storing it in temp
	}
        temp[b] = '\0';
        *result = temp;
	return retval;
}

bool_t
enc_1_svc(listt *argp, char **result, struct svc_req *rqstp)
{
	bool_t retval = 1;
	char* temp = malloc(sizeof(char) * 10000);
        char* tempp = malloc(sizeof(char) * 10000);
        int a,b,c,j=0,i = 0,q=0;
        *result = argp->st; //copying the string to result
        a = strlen(*result); //finding the length of the string
        char str;
	tempp = *result;
        for(i = 0; i < a; i++)
        {
        str = tempp[i];
        b = (int)str;
        if(b > 64 && b < 91) //checking if character is a lower case alphabet
        {
         b = b - 64;
         b = b + 1;
         if(b == 27)
         {
          b = 1;
         }
         b = b + 64;

         temp[i] =(char)b; // storing encrypted character into temp
        }
        else if(b > 96 && b < 123) //checking if character upper case alphabet
        {
         b = b - 96;
         b = b + 1;
         if(b == 27)
         {
          b = 1;
         }
         b = b + 96;
         temp[i] = (char)b; // storing encrypted character into temp
        }
        else if(isdigit(str)) //checking if character is a digit
        {
         b = b + 1; //encrypting the character
         temp[i] = (char)b; //storing the character in temp
        }
        else
        {
         temp[i] = str;
        }
	q++;
        }
	temp[q+1] = '\0';
	*result = temp;
	return retval;
}

bool_t
del_1_svc(listt *argp, char **result, struct svc_req *rqstp)
{
	bool_t retval = 1;
	int a = 0,status;
        char* temp = malloc(sizeof(char) * 10000);
        char* tempp = malloc(sizeof(char) * 10000);
        *result = argp->st; //copying the client sent string to result
        temp = *result;
        status = remove(temp); //deleting the file and storing the result
        if(status == 0)
        {
	tempp = "Deletion Successful\0";
        }
        else
        {
	tempp = "Deletion Failed\0";
        }
	strcpy(*result, tempp);
	return retval;
}

bool_t
conc_1_svc(list *argp, char **result, struct svc_req *rqstp)
{
	bool_t retval = 1;
	int a = 0;
	char* stor = malloc(sizeof(char) * 10000);
        char* temp = malloc(sizeof(char) * 10000);
	char* tempp = malloc(sizeof(char) * 10000);
	temp = argp->str; //access the first string and copying it to result
	tempp = argp->strr; //access the second string and copy it to result
	stor = strcat(temp, tempp); // concatenate and store to result
        a = strlen(stor);
	stor[a] = '\0';
	*result =  stor;
	return retval;
}

int
selprog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	//xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
